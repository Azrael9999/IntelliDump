using System;
using System.Linq;
using IntelliDump.Diagnostics;
using IntelliDump.Reasoning;
using QuestPDF.Fluent;
using QuestPDF.Helpers;
using QuestPDF.Infrastructure;

namespace IntelliDump.Reporting;

public static class PdfReportBuilder
{
    public static void Build(string path, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        var document = Document.Create(container =>
        {
            container.Page(page =>
            {
                page.Size(PageSizes.A4);
                page.Margin(30);
                page.DefaultTextStyle(TextStyle.Default.FontSize(11));
                page.Header().Element(e => Header(e, snapshot));
                page.Content().Element(e => Body(e, snapshot, issues));
                page.Footer().AlignCenter().Text(x => x.Span($"Generated by IntelliDump • {DateTime.UtcNow:u}"));
            });
        });

        document.GeneratePdf(path);
    }

    private static void Header(IContainer container, DumpSnapshot snapshot)
    {
        container.Row(row =>
        {
            row.RelativeItem().Column(col =>
            {
                col.Item().Text("IntelliDump Report").FontSize(20).SemiBold();
                col.Item().Text($"Dump: {snapshot.DumpPath}").FontColor(Colors.Grey.Darken2);
                col.Item().Text($"Runtime: {snapshot.RuntimeDescription}").FontColor(Colors.Grey.Darken2);
            });

            row.ConstantItem(100).AlignRight().Text(x =>
            {
                x.Span($"Threads: {snapshot.Threads.Count}\n");
                x.Span($"Warnings: {snapshot.Warnings.Count}");
            });
        });
    }

    private static void Body(IContainer container, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        container.PaddingTop(10).Column(col =>
        {
            col.Item().Text("Summary").FontSize(16).SemiBold();
            col.Item().Text($"Findings: {issues.Count} | Deadlocks: {snapshot.DeadlockCandidates.Count} | Warnings: {snapshot.Warnings.Count} | LOH: {snapshot.Gc.LargeObjectHeapBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Threads shown: {snapshot.Threads.Count} of {snapshot.TotalThreadCount}; Strings: {snapshot.UniqueStringCount} unique / {snapshot.TotalStringOccurrences} occurrences (stack {snapshot.StackStringOccurrences}, heap {snapshot.HeapStringOccurrences})");
            col.Item().Text($"Heap types shown: {snapshot.HeapTypes.Count} of {snapshot.TotalHeapTypeCount} covering {(snapshot.HeapHistogramCoverage * 100):N1}% of managed heap ({snapshot.TotalHeapObjectCount:N0} objects over {snapshot.Gc.TotalHeapBytes / (1024 * 1024):N0} MB); Modules shown: {Math.Min(20, snapshot.LoadedModules.Count)} of {snapshot.TotalModuleCount} covering {(snapshot.ModuleCoverageShown * 100):N1}% of {snapshot.TotalModuleBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Threads analyzed: {snapshot.Threads.Count} shown of {snapshot.TotalThreadCount} total");
            if (snapshot.DeadlockCandidates.Count > 0)
            {
                var first = snapshot.DeadlockCandidates.First();
                col.Item().Text($"Deadlock candidates detected: {snapshot.DeadlockCandidates.Count} (e.g., object 0x{first.ObjectAddress:X} owner={first.OwnerThreadId?.ToString() ?? "unknown"} waiting={first.WaitingThreads})").FontColor(Colors.Red.Medium);
            }
            if (snapshot.Warnings.Count > 0)
            {
                col.Item().Text($"Data warnings present (see Warnings section)").FontColor(Colors.Red.Medium);
            }

            col.Item().PaddingVertical(8).Row(row =>
            {
                row.RelativeItem().Background("#f3f4f6").Padding(8).Text("Findings (tap to jump)").SemiBold();
            });

            for (var i = 0; i < issues.Count; i++)
            {
                var anchor = $"issue-{i + 1}";
                var issue = issues[i];
                col.Item().Text(x =>
                {
                    x.Span("• ").FontColor(Colors.Blue.Medium);
                    x.Hyperlink(issue.Title, $"#{anchor}").FontSize(12).SemiBold();
                });
            }

            col.Item().PaddingVertical(10).Element(c => FindingsSection(c, snapshot, issues));
            col.Item().PaddingVertical(10).Element(c => ThreadsSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => GcSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => StringsSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => ModulesSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => WarningsSection(c, snapshot));
        });
    }

    private static void FindingsSection(IContainer container, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        container.Column(col =>
        {
            col.Item().Text("Findings").FontSize(16).SemiBold();
            for (var i = 0; i < issues.Count; i++)
            {
                var anchor = $"issue-{i + 1}";
                var issue = issues[i];
                col.Item().Border(1).BorderColor(Colors.Grey.Lighten2).Padding(8).Column(c =>
                {
                    // With this:
                    c.Item().Text(x =>
                    {
                        x.Span($"{issue.Severity}: ").SemiBold();
                        x.Hyperlink(issue.Title, $"#{anchor}").SemiBold();
                    });
                    c.Item().Text(issue.Evidence);
                    c.Item().Text(issue.Recommendation).FontColor(Colors.Grey.Darken2);
                });
            }
        });
    }

    private static void ThreadsSection(IContainer container, DumpSnapshot snapshot)
    {
        container.Column(col =>
        {
            const int threadDisplay = 10;
            col.Item().Text($"Threads (top {Math.Min(threadDisplay, snapshot.Threads.Count)} of {snapshot.TotalThreadCount})").FontSize(16).SemiBold();
            foreach (var thread in snapshot.Threads.Take(threadDisplay))
            {
                var truncated = thread.CapturedStackFrames < thread.RequestedStackFrames ? " (truncated)" : string.Empty;
                col.Item().PaddingBottom(6).Text($"#{thread.ManagedId} {thread.State} Locks:{thread.LockCount} Exception:{thread.CurrentException ?? "none"} Frames:{thread.CapturedStackFrames}/{thread.RequestedStackFrames}{truncated} CPUms:{thread.CpuTimeMs?.ToString("N0") ?? "n/a"}");
                if (thread.Stack.Count > 0)
                {
                    col.Item().Text(t =>
                    {
                        t.Span("Stack: ").SemiBold();
                        t.Span(string.Join(" | ", thread.Stack));
                    });
                }
            }
        });
    }

    private static void GcSection(IContainer container, DumpSnapshot snapshot)
    {
        container.Column(col =>
        {
            col.Item().Text("GC & Memory").FontSize(16).SemiBold();
            col.Item().Text($"Total: {snapshot.Gc.TotalHeapBytes / (1024 * 1024):N0} MB | LOH: {snapshot.Gc.LargeObjectHeapBytes / (1024 * 1024):N0} MB | Pinned: {snapshot.Gc.PinnedBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Gen0: {snapshot.Gc.Gen0Bytes / (1024 * 1024):N0} MB | Gen1: {snapshot.Gc.Gen1Bytes / (1024 * 1024):N0} MB | Gen2: {snapshot.Gc.Gen2Bytes / (1024 * 1024):N0} MB");

            if (snapshot.HeapTypes.Count > 0)
            {
                const int heapDisplay = 10;
                col.Item().Text($"Top heap types (top {Math.Min(heapDisplay, snapshot.HeapTypes.Count)} of {snapshot.TotalHeapTypeCount}, covering {(snapshot.HeapHistogramCoverage * 100):N1}%):").SemiBold();
                foreach (var type in snapshot.HeapTypes.Take(heapDisplay))
                {
                    col.Item().Text($"- {type.TypeName} ({type.TotalSize / (1024 * 1024):N0} MB across {type.Count:N0})");
                }
            }
        });
    }

    private static void StringsSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.Strings.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            const int stringDisplay = 10;
            col.Item().Text($"Captured strings (top {Math.Min(stringDisplay, snapshot.Strings.Count)} of {snapshot.Strings.Count})").FontSize(16).SemiBold();
            foreach (var s in snapshot.Strings.Take(stringDisplay))
            {
                var threadInfo = s.ThreadIds.Count == 0 ? "heap" : string.Join(", ", s.ThreadIds.Take(5));
                if (s.ThreadIds.Count > 5)
                {
                    threadInfo += " ...";
                }

                col.Item().Text($"[{s.Source}] count={s.Occurrences:N0} threads={threadInfo} len={s.TotalLength:N0}{(s.WasTruncated ? " (truncated)" : "")}");
                col.Item().Text(s.Value).FontColor(Colors.Grey.Darken2);
            }

            var hotDuplicates = snapshot.Strings
                .Where(s => s.Occurrences > 1)
                .OrderByDescending(s => s.Occurrences)
                .Take(5)
                .ToList();
            if (hotDuplicates.Count > 0)
            {
                col.Item().PaddingTop(6).Text("Top duplicate strings").SemiBold();
                foreach (var dup in hotDuplicates)
                {
                    col.Item().Text($"- count={dup.Occurrences:N0} len={dup.TotalLength:N0} sample: {dup.Value}");
                }
            }
        });
    }

    private static void ModulesSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.LoadedModules.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            const int moduleDisplay = 20;
            col.Item().Text($"Managed modules (top {Math.Min(moduleDisplay, snapshot.LoadedModules.Count)} of {snapshot.TotalModuleCount})").FontSize(16).SemiBold();
            foreach (var m in snapshot.LoadedModules.OrderByDescending(m => m.Size).Take(moduleDisplay))
            {
                col.Item().Text($"- {m.Name} ({m.Size / 1024:N0} KB)");
            }
        });
    }

    private static void WarningsSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.Warnings.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            col.Item().Text("Warnings").FontSize(16).SemiBold();
            foreach (var group in snapshot.Warnings.GroupBy(w => w.Category))
            {
                col.Item().Text(group.Key.ToString()).SemiBold();
                foreach (var w in group)
                {
                    col.Item().Text($"- {w.Message}").FontColor(Colors.Red.Medium);
                }
            }
        });
    }

}
