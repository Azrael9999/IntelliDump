using System;
using System.Collections.Generic;
using System.Linq;
using IntelliDump.Diagnostics;
using IntelliDump.Reasoning;
using QuestPDF.Fluent;
using QuestPDF.Helpers;
using QuestPDF.Infrastructure;

namespace IntelliDump.Reporting;

public static class PdfReportBuilder
{
    public static void Build(string path, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        var document = Document.Create(container =>
        {
            container.Page(page =>
            {
                page.Size(PageSizes.A4);
                page.Margin(30);
                page.DefaultTextStyle(TextStyle.Default.FontSize(11));
                page.Header().Element(e => Header(e, snapshot));
                page.Content().Element(e => Body(e, snapshot, issues));
                page.Footer().AlignCenter().Text(x => x.Span($"Generated by IntelliDump • {DateTime.UtcNow:u}"));
            });
        });

        document.GeneratePdf(path);
    }

    private static void Header(IContainer container, DumpSnapshot snapshot)
    {
        container.Row(row =>
        {
            row.RelativeItem().Column(col =>
            {
                col.Item().Text("IntelliDump Report").FontSize(20).SemiBold();
                col.Item().Text($"Dump: {snapshot.DumpPath}").FontColor(Colors.Grey.Darken2);
                col.Item().Text($"Runtime: {snapshot.RuntimeDescription}").FontColor(Colors.Grey.Darken2);
            });

            row.ConstantItem(100).AlignRight().Text(x =>
            {
                x.Span($"Threads: {snapshot.Threads.Count}\n");
                x.Span($"Warnings: {snapshot.Warnings.Count}");
            });
        });
    }

    private static void Body(IContainer container, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        container.PaddingTop(10).Column(col =>
        {
            col.Item().Text("Summary").FontSize(16).SemiBold();
            col.Item().Text($"Findings: {issues.Count} | Deadlocks: {snapshot.DeadlockCandidates.Count} | Warnings: {snapshot.Warnings.Count} | LOH: {snapshot.Gc.LargeObjectHeapBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Threads shown: {snapshot.Threads.Count} of {snapshot.TotalThreadCount}; Strings: {snapshot.UniqueStringCount} unique / {snapshot.TotalStringOccurrences} occurrences (stack {snapshot.StackStringOccurrences}, heap {snapshot.HeapStringOccurrences})");
            col.Item().Text($"Heap types shown: {snapshot.HeapTypes.Count} of {snapshot.TotalHeapTypeCount} covering {(snapshot.HeapHistogramCoverage * 100):N1}% of managed heap ({snapshot.TotalHeapObjectCount:N0} objects over {snapshot.Gc.TotalHeapBytes / (1024 * 1024):N0} MB); Modules shown: {Math.Min(20, snapshot.LoadedModules.Count)} of {snapshot.TotalModuleCount} covering {(snapshot.ModuleCoverageShown * 100):N1}% of {snapshot.TotalModuleBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Threads analyzed: {snapshot.Threads.Count} shown of {snapshot.TotalThreadCount} total");
            col.Item().PaddingVertical(6).Background(Colors.Grey.Lighten4).Padding(8).Text(t =>
            {
                t.Span("How to read this report: ").SemiBold();
                t.Span("Each section below summarizes what was found in the dump. The Deadlocks & Blocking section lists which threads hold locks and who appears to be waiting on them. Threads are printed with their key stack frames so you can quickly see what code is blocking others.");
            });
            if (snapshot.DeadlockCandidates.Count > 0)
            {
                var first = snapshot.DeadlockCandidates.First();
                col.Item().Text($"Deadlock candidates detected: {snapshot.DeadlockCandidates.Count} (e.g., object 0x{first.ObjectAddress:X} owner={first.OwnerThreadId?.ToString() ?? "unknown"} waiting={first.WaitingThreads}). See Deadlocks & Blocking for thread details.").FontColor(Colors.Red.Medium);
            }
            if (snapshot.Warnings.Count > 0)
            {
                col.Item().Text($"Data warnings present (see Warnings section)").FontColor(Colors.Red.Medium);
            }

            col.Item().PaddingVertical(8).Row(row =>
            {
                row.RelativeItem().Background("#f3f4f6").Padding(8).Text("Findings (tap to jump)").SemiBold();
            });

            for (var i = 0; i < issues.Count; i++)
            {
                var anchor = $"issue-{i + 1}";
                var issue = issues[i];
                col.Item().Text(x =>
                {
                    x.Span("• ").FontColor(Colors.Blue.Medium);
                    x.Hyperlink(issue.Title, $"#{anchor}").FontSize(12).SemiBold();
                });
            }

            col.Item().PaddingVertical(10).Element(c => FindingsSection(c, snapshot, issues));
            col.Item().PaddingVertical(10).Element(c => DeadlocksAndBlockingSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => ThreadsSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => GcSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => StringsSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => ModulesSection(c, snapshot));
            col.Item().PaddingVertical(10).Element(c => WarningsSection(c, snapshot));
        });
    }

    private static void DeadlocksAndBlockingSection(IContainer container, DumpSnapshot snapshot)
    {
        container.Column(col =>
        {
            col.Item().Text("Deadlocks & Blocking").FontSize(16).SemiBold();

            if (snapshot.DeadlockCandidates.Count == 0 && snapshot.Blocking.SyncBlockCount == 0)
            {
                col.Item().Text("No lock contention signals were detected.");
            }
            else
            {
                if (snapshot.DeadlockCandidates.Count > 0)
                {
                    col.Item().Text($"Deadlock candidates: {snapshot.DeadlockCandidates.Count}. Objects are shown with their owner and approximate waiters.").FontColor(Colors.Red.Medium);
                    foreach (var deadlock in snapshot.DeadlockCandidates)
                    {
                        var owner = deadlock.OwnerThreadId?.ToString() ?? "unknown";
                        var ownerThread = snapshot.Threads.FirstOrDefault(t => t.ManagedId == deadlock.OwnerThreadId);
                        col.Item().Border(1).BorderColor(Colors.Grey.Lighten2).Padding(8).Column(c =>
                        {
                            c.Item().Text($"Object 0x{deadlock.ObjectAddress:X}").SemiBold();
                            c.Item().Text($"Owner thread: {owner}; Waiting threads: {deadlock.WaitingThreads}");
                            if (ownerThread is not null)
                            {
                                c.Item().Text("Owner stack:").SemiBold();
                                c.Item().Text(string.Join(" → ", ownerThread.Stack.Take(8)));
                            }
                        });
                    }
                }

                col.Item().PaddingTop(6).Text($"Sync blocks observed: {snapshot.Blocking.SyncBlockCount}; Waiting threads seen: {snapshot.Blocking.WaitingThreadCount}.").FontColor(Colors.Grey.Darken1);
            }

            var blockingThreads = snapshot.Threads
                .Where(t => t.LockCount > 0)
                .OrderByDescending(t => t.LockCount)
                .ThenBy(t => t.ManagedId)
                .Take(12)
                .ToList();

            if (blockingThreads.Count > 0)
            {
                col.Item().PaddingTop(8).Text("Threads holding locks (top 12)").SemiBold();
                foreach (var thread in blockingThreads)
                {
                    col.Item().BorderBottom(0.5f).BorderColor(Colors.Grey.Lighten3).PaddingVertical(4).Text(t =>
                    {
                        t.Span($"#{thread.ManagedId} ").SemiBold();
                        t.Span($"State: {thread.State}; Locks held: {thread.LockCount}; CPUms: {thread.CpuTimeMs?.ToString("N0") ?? "n/a"}");
                        if (!string.IsNullOrWhiteSpace(thread.CurrentException))
                        {
                            t.Span($" | Exception: {thread.CurrentException}").FontColor(Colors.Red.Medium);
                        }
                    });
                    col.Item().Text(string.Join(" → ", thread.Stack.Take(6))).FontColor(Colors.Grey.Darken2);
                }
            }

            var waitingThreads = snapshot.Threads
                .Where(t => t.State.Contains("Wait", StringComparison.OrdinalIgnoreCase) || t.State.Contains("Block", StringComparison.OrdinalIgnoreCase))
                .OrderByDescending(t => t.Stack.Count)
                .ThenBy(t => t.ManagedId)
                .Take(12)
                .ToList();

            if (waitingThreads.Count > 0)
            {
                col.Item().PaddingTop(8).Text("Threads waiting on locks or resources (top 12)").SemiBold();
                foreach (var thread in waitingThreads)
                {
                    col.Item().BorderBottom(0.5f).BorderColor(Colors.Grey.Lighten3).PaddingVertical(4).Text(t =>
                    {
                        t.Span($"#{thread.ManagedId} ").SemiBold();
                        t.Span($"State: {thread.State}; Locks held: {thread.LockCount}; CPUms: {thread.CpuTimeMs?.ToString("N0") ?? "n/a"}");
                    });
                    col.Item().Text(string.Join(" → ", thread.Stack.Take(6))).FontColor(Colors.Grey.Darken2);
                }
            }
        });
    }

    private static void FindingsSection(IContainer container, DumpSnapshot snapshot, IReadOnlyList<AnalysisIssue> issues)
    {
        container.Column(col =>
        {
            col.Item().Text("Findings").FontSize(16).SemiBold();
            for (var i = 0; i < issues.Count; i++)
            {
                var anchor = $"issue-{i + 1}";
                var issue = issues[i];
                col.Item().Border(1).BorderColor(Colors.Grey.Lighten2).Padding(8).Column(c =>
                {
                    c.Item().Element(e => e.Anchor(anchor)).Text($"{issue.Severity}: {issue.Title}").SemiBold();
                    c.Item().Text(issue.Evidence);
                    c.Item().Text(issue.Recommendation).FontColor(Colors.Grey.Darken2);
                });
            }
        });
    }

    private static void ThreadsSection(IContainer container, DumpSnapshot snapshot)
    {
        container.Column(col =>
        {
            const int threadDisplay = 10;
            col.Item().Text($"Threads (top {Math.Min(threadDisplay, snapshot.Threads.Count)} of {snapshot.TotalThreadCount})").FontSize(16).SemiBold();
            foreach (var thread in snapshot.Threads.Take(threadDisplay))
            {
                var truncated = thread.CapturedStackFrames < thread.RequestedStackFrames ? " (truncated)" : string.Empty;
                col.Item().PaddingBottom(6).Text($"#{thread.ManagedId} {thread.State} Locks:{thread.LockCount} Exception:{thread.CurrentException ?? "none"} Frames:{thread.CapturedStackFrames}/{thread.RequestedStackFrames}{truncated} CPUms:{thread.CpuTimeMs?.ToString("N0") ?? "n/a"}");
                if (thread.Stack.Count > 0)
                {
                    col.Item().Text(t =>
                    {
                        t.Span("Stack: ").SemiBold();
                        t.Span(string.Join(" | ", thread.Stack));
                    });
                }
            }
        });
    }

    private static void GcSection(IContainer container, DumpSnapshot snapshot)
    {
        container.Column(col =>
        {
            col.Item().Text("GC & Memory").FontSize(16).SemiBold();
            col.Item().Text($"Total: {snapshot.Gc.TotalHeapBytes / (1024 * 1024):N0} MB | LOH: {snapshot.Gc.LargeObjectHeapBytes / (1024 * 1024):N0} MB | Pinned: {snapshot.Gc.PinnedBytes / (1024 * 1024):N0} MB");
            col.Item().Text($"Gen0: {snapshot.Gc.Gen0Bytes / (1024 * 1024):N0} MB | Gen1: {snapshot.Gc.Gen1Bytes / (1024 * 1024):N0} MB | Gen2: {snapshot.Gc.Gen2Bytes / (1024 * 1024):N0} MB");

            if (snapshot.HeapTypes.Count > 0)
            {
                const int heapDisplay = 10;
                col.Item().Text($"Top heap types (top {Math.Min(heapDisplay, snapshot.HeapTypes.Count)} of {snapshot.TotalHeapTypeCount}, covering {(snapshot.HeapHistogramCoverage * 100):N1}%):").SemiBold();
                foreach (var type in snapshot.HeapTypes.Take(heapDisplay))
                {
                    col.Item().Text($"- {type.TypeName} ({type.TotalSize / (1024 * 1024):N0} MB across {type.Count:N0})");
                }
            }
        });
    }

    private static void StringsSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.Strings.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            const int stringDisplay = 10;
            col.Item().Text($"Captured strings (top {Math.Min(stringDisplay, snapshot.Strings.Count)} of {snapshot.Strings.Count})").FontSize(16).SemiBold();
            foreach (var s in snapshot.Strings.Take(stringDisplay))
            {
                var threadInfo = s.ThreadIds.Count == 0 ? "heap" : string.Join(", ", s.ThreadIds.Take(5));
                if (s.ThreadIds.Count > 5)
                {
                    threadInfo += " ...";
                }

                col.Item().Text($"[{s.Source}] count={s.Occurrences:N0} threads={threadInfo} len={s.TotalLength:N0}{(s.WasTruncated ? " (truncated)" : "")}");
                col.Item().Text(s.Value).FontColor(Colors.Grey.Darken2);
            }

            var hotDuplicates = snapshot.Strings
                .Where(s => s.Occurrences > 1)
                .OrderByDescending(s => s.Occurrences)
                .Take(5)
                .ToList();
            if (hotDuplicates.Count > 0)
            {
                col.Item().PaddingTop(6).Text("Top duplicate strings").SemiBold();
                foreach (var dup in hotDuplicates)
                {
                    col.Item().Text($"- count={dup.Occurrences:N0} len={dup.TotalLength:N0} sample: {dup.Value}");
                }
            }
        });
    }

    private static void ModulesSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.LoadedModules.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            const int moduleDisplay = 20;
            col.Item().Text($"Managed modules (top {Math.Min(moduleDisplay, snapshot.LoadedModules.Count)} of {snapshot.TotalModuleCount})").FontSize(16).SemiBold();
            foreach (var m in snapshot.LoadedModules.OrderByDescending(m => m.Size).Take(moduleDisplay))
            {
                col.Item().Text($"- {m.Name} ({m.Size / 1024:N0} KB)");
            }
        });
    }

    private static void WarningsSection(IContainer container, DumpSnapshot snapshot)
    {
        if (snapshot.Warnings.Count == 0)
        {
            return;
        }

        container.Column(col =>
        {
            col.Item().Text("Warnings").FontSize(16).SemiBold();
            foreach (var group in snapshot.Warnings.GroupBy(w => w.Category))
            {
                col.Item().Text(group.Key.ToString()).SemiBold();
                foreach (var w in group)
                {
                    col.Item().Text($"- {w.Message}").FontColor(Colors.Red.Medium);
                }
            }
        });
    }

}
